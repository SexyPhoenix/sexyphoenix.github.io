{"meta":{"title":"SexyPhoenix的博客","subtitle":"博客","description":"这是一个分享技术的个人博客","author":"SexyPhoenix","url":"https://sexyphoenix.github.io"},"pages":[{"title":"categories","date":"2019-09-06T07:29:46.000Z","updated":"2019-09-06T07:29:46.685Z","comments":true,"path":"categories/index.html","permalink":"https://sexyphoenix.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"用户认证","slug":"用户认证","date":"2019-09-06T08:23:46.000Z","updated":"2019-09-06T08:24:53.386Z","comments":true,"path":"用户认证/","link":"","permalink":"https://sexyphoenix.github.io/用户认证/","excerpt":"","text":"前期准备Laravel的权限配置文件位于 config/auth.php，Laravel的认证组件由“guards”和“providers”组成，Guard 通过 session 来维护用户登录的状态。Provider 是登录以及访问页面的时候获取用户的信息。本篇主要讲的是如何自定义Provider ，获取用户信息。 config/auth.php文件Laravel提供了两种guard，web以及api，采取默认的web认证。在guards的web中，用了users提供者。接下来就需要注意了，我们自定义了服务提供者，就需要换到新的providers。首先，定义一个使用新驱动的provider： 123456 &apos;providers&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;Focus&apos;, //名称自定义，这里为Focus &apos;model&apos; =&gt; App\\Models\\User::class, //Model放在Models文件夹下 ],], Notes: 默认提供了两种驱动database和eloquent，而这两种的提供者分别是DatabaseUserProvider和EloquentUserProvider，都处于laravel\\framework\\src\\Illuminate\\Auth文件夹下，实现了UserProvider，我们自定义的 Focus provider 也将实现UserProvider。 生成路由和视图1php artisan make:auth //命令可快速生成认证所需要的路由和视图 Http/Controllers 和 resources/views下会相应生成控制器和视图默认用的Email，我们用username LoginController：//添加此方法，返回username 123public function username()&#123; return &apos;username&apos;;&#125; login.blade.php：将邮箱改为域账号，email 改为username 数据库修改.env配置中的数据库信息。 1php artisan make:model Models/User // 使用命令创建User模型 默认User是继承Model的，需要修改。 123456789use Illuminate\\Foundation\\Auth\\User as Authenticatable; //引入Authenticatableclass User extends Authenticatable&#123; protected $table = &apos;employee&apos;; protected $primaryKey = &apos;employee_id&apos;; //can set all fields to user model protected $guarded = [];&#125; 为什么要引入Authenticatable呢，是因为Authenticatable实现了Illuminate\\Contracts\\Auth\\Authenticatable接口，而FocusUserProvider 需要用到接口的实现。 创建扩展在app下新建 Extensions/FocusUserProvider 文件，参考DatabaseUserProvider和EloquentUserProvider，实现UserProvider： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374namespace App\\Extensions;use App\\Services\\LdapValidator;use Illuminate\\Support\\Str;use Illuminate\\Contracts\\Auth\\UserProvider;use \\Illuminate\\Contracts\\Auth\\Authenticatable; class LaravelUserProvider implements UserProvider &#123; protected $model; public function __construct($model) &#123; $this-&gt;model = $model; &#125; //登录成功后，通过此方法获取用户信息，返回匹配该ID的 Authenticatable 实现 public function retrieveById($identifier) &#123; //此处可以将信息放入缓存，缓解数据库压力。 $model = $this-&gt;createModel(); return $model-&gt;newQuery() -&gt;where($model-&gt;getAuthIdentifierName(), $identifier) -&gt;first(); &#125; public function retrieveByToken($identifier, $token) &#123; &#125; public function updateRememberToken(Authenticatable $user, $token) &#123; &#125; //该方法可以根据账号名去查询数据库是否存在匹配的账号 public function retrieveByCredentials(array $credentials) &#123; if (empty($credentials)) &#123; return; &#125; // First we will add each credential element to the query as a where clause. // Then we can execute the query and, if we found a user, return it in a // Eloquent User &quot;model&quot; that will be utilized by the Guard instances. $query = $this-&gt;createModel()-&gt;newQuery(); foreach ($credentials as $key =&gt; $value) &#123; if (! Str::contains($key, &apos;password&apos;)) &#123; $query-&gt;where($key, $value); &#125; &#125; return $query-&gt;first(); &#125; //该方法可以验证密码是否正确，因为我们是ldap登录，可以在此验证域账号 public function validateCredentials(Authenticatable $user, array $credentials) &#123; //LdapValidator类是为了验证域密码的，放在了app/Services，在上面已经引入 $Ldap = new LdapValidator($user-&gt;username, $credentials[&apos;password&apos;]); return $Ldap-&gt;validatePassword(); &#125; /** * Create a new instance of the model. * * @return \\Illuminate\\Database\\Eloquent\\Model */ public function createModel() &#123; $class = &apos;\\\\&apos;.ltrim($this-&gt;model, &apos;\\\\&apos;); return new $class; &#125;&#125; 注册提供者Laravel 提供了AuthServiceProvider， 我们可以在这里注册。 12345678910public function boot()&#123; $this-&gt;registerPolicies(); //Focus为auth.php里面定义的驱动 Auth::provider(&apos;Focus&apos;, function($app, array $config)&#123; return new FocusUserProvider ($config[&apos;model&apos;]); &#125;);&#125; 下面就可以访问http://你的域名/login 登录系统","categories":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}]},{"title":"生命的意义","slug":"生命的意义","date":"2019-09-06T08:11:47.000Z","updated":"2019-09-06T08:21:47.640Z","comments":true,"path":"生命的意义/","link":"","permalink":"https://sexyphoenix.github.io/生命的意义/","excerpt":"","text":"我们该如何找出生命的意义呢？ 我（霍金）认为答案非常清楚 意义本身不过就是 每个人在大脑里建构的现实模型其中一部分 生命的意义为何 全由你来选择 个人来说 我很乐意 我们每一个人都赋予宇宙意义 如宇宙学家卡尔·萨根所说 我们是宇宙对自己的省思 意义只能存在于人类心智的架构内 如此一来 生命的意义就不在外面某处 而在我们的脑海里 就许多方面来说 我们也因此成了万物之灵","categories":[],"tags":[],"keywords":[]}]}