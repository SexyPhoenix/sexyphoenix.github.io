{"meta":{"title":"SexyPhoenix的博客","subtitle":"博客","description":"这是一个分享技术的个人博客","author":"SexyPhoenix","url":"https://sexyphoenix.github.io"},"pages":[{"title":"categories","date":"2019-09-06T07:29:46.000Z","updated":"2019-09-06T07:29:46.685Z","comments":true,"path":"categories/index.html","permalink":"https://sexyphoenix.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"消息中心（实现）","slug":"消息中心（实现）","date":"2019-09-06T08:31:35.000Z","updated":"2019-09-06T08:34:39.141Z","comments":true,"path":"PHP/消息中心（实现）/","link":"","permalink":"https://sexyphoenix.github.io/PHP/消息中心（实现）/","excerpt":"","text":"前言 在上一章主要梳理了信息中心的运行机制，了解了服务端是如何把更新的信息主动推送给客户端的，接下来我会介绍下消息中心是如何搭建的以及现在可能会出现问题。 背景知识 laravel 队列运行机制：队列消息中心实现逻辑：消息中心（逻辑） 消息中心1.设置配置.env文件 12BROADCAST_DRIVER = redisQUEUE_DRIVER=redis config/app.php 1App\\Providers\\BroadcastServiceProvider::class //加载 2. 设置路由//设置用户频道，以便客户端监听。为了方便，直接返回true 123Broadcast::channel(&apos;todoevent.updated.*&apos;, function($user, $userId)&#123; return true;&#125;); 3. 添加predis依赖1composer require predis/predis 4. 创建事件类1php artisan make:event TodoEventUpdated //默认是不实现ShouldBroadcast接口 12345678910111213141516171819202122232425 class TodoEventUpdated implements ShouldBroadcast &#123; use InteractsWithSockets, SerializesModels; public $event; public function __construct($event) &#123; $this-&gt;event= $event; &#125; //添加私人频道，于路由设置一致 public function broadcastOn() &#123; if($this-&gt;event) &#123; return new PrivateChannel(&apos;todoevent.updated.&apos; . $this-&gt;event-&gt;get(&apos;user_id&apos;)); &#125; &#125; //可对事件内容作修改。返回客户端需要的内容 // public function broadcastWith() // &#123; // &#125;&#125; 5. 测试广播已到redisHomeController.php 12345use App\\Events\\TodoEventUpdated;public function index()&#123; broadcast(new TodoEventUpdated(collect([&apos;user_id&apos; =&gt; 8164]))); &#125; 执行home/index后，查看redis客户端 12&quot;SELECT&quot; &quot;0&quot;&quot;RPUSH&quot; &quot;queues:default&quot; &quot;&#123;event&#125;&quot; event已经写入redis，代表redis连接成功 6. 开启消费进程1php artisan queue:work //发现事件已被消费 12Processing: App\\Events\\TodoEventUpdatedProcessed: App\\Events\\TodoEventUpdated 7. 安装 laravel-echo-server，订阅redis1cnpm install -g laravel-echo-server 安装成功后，移步到项目下 12laravel-echo-server init //初始化laravel-echo-server start //启动 laravel-echo-server 已成功的监听了 redis 。注：laravel-echo-server 运行在6001端口，如果你用的是homestead等集成环境，请查看端口是否开启 8. 安装socket.io-client、laravel-echo12cnpm i --save socket.io-clientcnpm i --save laravel-echo 打开/resources/assets/js/bootstrap.js，会出现下面代码 123456import Echo from &apos;laravel-echo&apos;window.Pusher = require(&apos;pusher-js&apos;);window.Echo = new Echo(&#123; broadcaster: &apos;pusher&apos;, key: &apos;your-pusher-key&apos;&#125;); 改造为： 12import Echo from &apos;laravel-echo&apos;window.LaravelEcho= Echo; 编译 1cnpm run dev 以上的事件广播都搭建完了。下面让第三方应用可以监听吧 9. 第三方应用监听1234567891011&lt;script src=&quot;http://xxx:6001/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; //引入socket.io客户端&lt;script src=&quot;text/javascript&quot;&gt; window.Echo = new LaravelEcho(&#123; broadcaster: &apos;socket.io&apos;, host: &apos;http://xxx:6001&apos; &#125;); Echo.private(&apos;todoevent.updated.8164&apos;) .listen(&apos;TodoEventUpdated&apos;, function(event) &#123; console.log(event); //获取的信息 &#125;);&lt;/script&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}]},{"title":"消息中心（逻辑）","slug":"消息中心（逻辑）","date":"2019-09-06T08:31:19.000Z","updated":"2019-09-06T08:34:03.478Z","comments":true,"path":"PHP/消息中心（逻辑）/","link":"","permalink":"https://sexyphoenix.github.io/PHP/消息中心（逻辑）/","excerpt":"","text":"前言 在构建web应用的时候，很多功能需要我们即时更新信息。当服务器上的数据被更新后，能够在客户端即时且无刷新的同步信息。为了解决这个问题，出现了websocket协议。 它可以使服务器和客户端一直保持通信，且通信是双向的。而Laravel的事件广播让Websocket获取事件变的更加方便。在我们的项目中（消息中心）用的就是Laravel的事件广播机制，接下来我会介绍下消息中心是如何运行的。 背景知识 WebService是一种跨编程语言和跨操作系统平台的远程调用技术，可以让客户端调用服务端上面的方法。消息中心通过WebService技术，添加或者取消代办事件。消息中心的事件广播是基于redis驱动的同步队列。socket.io是nodejs对websocket协议的封装。socket.io分为客户端和服务端，通过websocket协议保持浏览器与服务器的双向通信。laravel-echo-server 使用 socket.io 实现了Laravel 广播的服务端。laravel-echo 是Laravel广播的客户端，支持socket.io 和 pusher，消息中心用的是socket.ioredis Pub/Sub ： redis使用字典这种数据类型实现了发布/订阅的功能，laravel-echo-server就是redis Pub/Sub 的订阅者，消费者进程向redis里面发布了一条事件，redis 通过Pub/Sub功能通知了laravel-echo-server。 消息广播 现在的代办功能其实分成了两个部分，第一个部分放在了新oa的event应用下，用于对事件信息的持久化以及对信息中心的通知。第二部分放在了信息中心系统（focusmessage），用于对用户客户端即时且无刷新的信息同步。 1. 代办事件添加/删除第三应用通过调用web api 将信息推送到webservice Service（A），Service端先对第三应用的ip做了判断，看是否在允许的地址里。通过，再对账号以及密码进行验证。两种验证只要有一种失败，就会返回验证失败信息。验证通过后，信息进行持久化，写入数据库（B）以及更新日历（C），最后通知信息中心（D）。 2. 消息中心消息中心获取到信息的更新，会对信息的来源ip做白名单判断，失败返回403，通过后广播这条信息，也就是推送到redis主队列中（E），消费者进程进行publish（F），laravel-echo-server接受到发布的信息后（G），通知socket.io service。 因为socket.io service和socket.io client 一直保持通信且一直监控相关频道中的事件，符合此频道中的事件后，发送给 socket.io client 后，laravel-echo 通过 socket.io 接受到信息，解析出信息后，显示给用户。 结尾 本来也想在本章写下如何搭建我们的信息中心，但想想感觉搭建的内容还是比较多的，就将如何搭建内容放在了下一章。此章就对待办事项的逻辑做了一下梳理。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}]},{"title":"API认证系统Passport","slug":"API认证系统Passport","date":"2019-09-06T08:31:10.000Z","updated":"2019-09-06T08:33:36.666Z","comments":true,"path":"PHP/API认证系统Passport/","link":"","permalink":"https://sexyphoenix.github.io/PHP/API认证系统Passport/","excerpt":"","text":"安装1composer require laravel/passport=~4.0 notes: 1）确保系统安装unzip、zip等命令。 2）composer 安装出现 Authentication required (packagist.phpcomposer.com) 问题，修改composer.json 中的源，repositories.packagist.url = https://packagist.laravel-china.org 。 注册服务提供者在config/app.php的providers 数组中加入 Laravel\\Passport\\PassportServiceProvider::class 迁移数据库1php artisan migrate //生成用于存储客户端和令牌的数据表 生成加密健1php artisan passport:install 1、生成oauth-private.key（用于构建认证服务器），oauth-public.key（用于构建资源服务器）2、oauth_clients数据库生成「个人访问」客户端和「密码授权]两条数据。 配置Passport（参考官方文档）在Model中，我们需要增加 HasApiTokens class在AuthServiceProvider中， 增加 “Passport::routes()”在 auth.php中， 更改 api 认证方式为passport 申请客户端以及私人访问令牌 （两种方式）1. 命令形式（不方便客户注册）1php artisan passport:client 2. Passport Vue 组件1php artisan vendor:publish --tag=passport-components //发布 Passport Vue，组件位于resources/assets/js/components下 //注册到resources/assets/js/app.js 文件，记得要放在new Vue上面 1234567891011121314Vue.component( &apos;passport-clients&apos;, require(&apos;./components/passport/Clients.vue&apos;));Vue.component( &apos;passport-authorized-clients&apos;, require(&apos;./components/passport/AuthorizedClients.vue&apos;));Vue.component( &apos;passport-personal-access-tokens&apos;, require(&apos;./components/passport/PersonalAccessTokens.vue&apos;)); //编译前端资源 12npm install //此处报错，移步larravel Mix文档npm run dev 编译后资源放在public/js/app.js下 //组件放入应用模板（记得引入编译后的app.js） 123&lt;passport-clients&gt;&lt;/passport-clients&gt;&lt;passport-authorized-clients&gt;&lt;/passport-authorized-clients&gt;&lt;passport-personal-access-tokens&gt;&lt;/passport-personal-access-tokens&gt; 以上认证服务器都已经搭建完成 第三方应用实现登录1. 申请客户端回调地址 http://third.plat.goods/dew/sso 申请授权码和访问令牌//获取授权码 code （第一次交互） 123456789$query = http_build_query(array( &apos;client_id&apos; =&gt; 3, &apos;redirect_uri&apos; =&gt; &apos;http://third.plat.goods/dew/sso&apos;, //地址必须为上面的回调地址 &apos;response_type&apos; =&gt; &apos;code&apos;, //固定值 &apos;scope&apos; =&gt; &apos;&apos;, &apos;state&apos; =&gt; urlencode(&apos;http://laravel.plat.goods/user&apos;) //可以放用户访问的地址。));return redirect(&apos;http://laravel.plat.goods/oauth/authorize?&apos;.$query); ///laravel.plat.goods为上面认证服务器 //获取访问令牌 access token 以及向资源服务器请求用户信息授权后会重定向回调地址 12Route::get(&apos;/dew/sso&apos;, &apos;SSOController@callback&apos;); //路由文件里添加php artisan make:controller SSOController //创建文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?phpnamespace App\\Http\\Controllers;use App\\Models\\User;use GuzzleHttp\\Client;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Log;class SSOController extends Controller&#123; protected $http; public function __construct() &#123; $this-&gt;http = new Client(); &#125; /** * 获取授权码后的回调URL * @param Request $request * @return \\Illuminate\\Http\\RedirectResponse */ public function callback(Request $request) &#123; $token = $this-&gt;token($request); //第二次交互 $login = $this-&gt;login($token);//第三次交互 if($login)&#123; if($request_url = $request-&gt;input(&apos;state&apos;, null))&#123; $request-&gt;session()-&gt;put(&apos;url.intended&apos;, urldecode($request_url)); &#125; return redirect()-&gt;intended(); //跳转到 http://laravel.plat.goods/user &#125;else&#123; return redirect()-&gt;to(&apos;http://laravel.plat.com/home/public/login&apos;); //服务提供商网站必须登录 &#125; &#125; /** * 获取access token * @param $request * @return array|mixed */ protected function token($request) &#123; $code = $request-&gt;code; if($code) &#123; try &#123; $response = $this-&gt;http-&gt;post(&apos;http://laravel.plat.goods/oauth/token&apos;, [ &apos;form_params&apos; =&gt; [ &apos;grant_type&apos; =&gt; &apos;authorization_code&apos;, //固定值 &apos;client_id&apos; =&gt; 3, &apos;client_secret&apos; =&gt; &apos;UihXNHoSqohdtQ8Js6Av7AOyk3GBNB9rJziDPaWf&apos;, &apos;redirect_uri&apos; =&gt; &apos;http://third.plat.goods/dew/sso&apos;, &apos;code&apos; =&gt; $code, ], ]); $response_data = json_decode((string)$response-&gt;getBody(), true); return $response_data; &#125; catch (\\Exception $e) &#123; Log::error(&apos;get token by code failed: &apos;.$code.&apos; - &apos;.$e-&gt;getMessage().&apos; - &apos;.$e-&gt;getTraceAsString()); return []; &#125; &#125;else&#123; return []; &#125; &#125; /** * 通过token获取用户信息，并进行登录操作 * @param $token * @return bool */ protected function login($token) &#123; if(empty($token)) return false; $access_token = $token[&apos;access_token&apos;]; try &#123; // 资源服务器和认证服务器放在了一起，可以独立。 $response = $this-&gt;http-&gt;request(&apos;GET&apos;, &apos;http://laravel.plat.goods/api/user&apos;, [ &apos;headers&apos; =&gt; [ &apos;Accept&apos; =&gt; &apos;application/json&apos;, &apos;Authorization&apos; =&gt; $token[&apos;token_type&apos;] . &apos; &apos; . $access_token, ] ]); $users_body = $response-&gt;getBody(); $data = json_decode($users_body, true); if($data) &#123; $user = new User($data); //because of employee_id is guarded $user-&gt;setAttribute($user-&gt;getKeyName(), $data[&apos;employee_id&apos;]); //login user in my system auth()-&gt;login($user, false); return true; &#125;else&#123; return false; &#125; &#125;catch (\\Exception $e)&#123; Log::error(&apos;get user failed by access_token:&apos;.$access_token.&apos;|&apos;.$e-&gt;getMessage()); return false; &#125; &#125;&#125; //设置资源文件 12Route::middleware(&apos;auth:api&apos;)-&gt;get(&apos;/user&apos;, &apos;UserController@user&apos;); //routes/api.php文件中设置php artisan make:controller UserController //创建文件 1234567class UserController extends Controller&#123; public function user(Request $request) &#123; return $request-&gt;user(); &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}]},{"title":"OAuth2.0","slug":"OAuth2-0","date":"2019-09-06T08:31:01.000Z","updated":"2019-09-06T08:33:08.532Z","comments":true,"path":"PHP/OAuth2-0/","link":"","permalink":"https://sexyphoenix.github.io/PHP/OAuth2-0/","excerpt":"","text":"OAuth 2.0定义了四种授权方式 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials）授权码模式是功能最完整、流程最严密的授权模式，本篇也是主要去理解这种模式 授权码模式大概分为 5 个步骤 客户端（Client）向服务提供商（HTTP service）申请创建客户端（Client_id、Client_Secret）。 用户（Resource Owner）通过浏览器（User Agent）打开后,跳转到授权页，客户端要求用户授权。 用户同意给予客户端授权，返回授权码（Code）。 客户端通过授权码，向认证服务器（Authorization server）申请令牌（Access Token）。 客户端通过令牌，向资源服务器（Resource server）获取资源。 1. 获取Code12345response_type：表示授权类型，必选项，此处的值固定为&quot;code&quot;client_id：表示客户端的ID，必选项redirect_uri：表示重定向URL，可选项scope：表示申请的权限范围，可选项state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 2. 返回Code（用户授权通过后返回到重定向URL）12code：表示授权码，必选项。state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 3. 客户端向认证服务器申请Access Token12345grant_type：表示使用的授权模式，必选项，此处的值固定为&quot;authorization_code&quot;。code：表示获得的授权码，必选项。redirect_uri：表示重定向URI，必选项，且必须与上面中的该参数值保持一致。client_id：表示客户端ID，必选项。client_secret ： 表示客户端密钥，必选项。 4. 认证服务器返回Access Token12345access_token：表示访问令牌，必选项。token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 5. 向资源服务器获取信息12headers.Accept ： media类型，固定值 “application/json”headers.Authorization 授权，值为返回的token_type + 空格 + access_token 疑问1. 获取code时，只传递了clent_id，redirect_url等值，服务提供商是怎么知道是哪个用户授权？ 授权时，你已经登录了服务提供商的网站或者会要求你登录。 2. 客户端是怎么知道你已经授权？ 授权请求发出后，浏览器得到的是一个http的重定向响应，这个地址是你的redirect_url，同时返回code值 3. 为什么要设置获取code后再去获取access_token 是为了安全性，直接通过重定向传回access_token，但是HTTP 302是不安全的， 攻击者有可能会获取到access_token，而code不能获取资源，即使被截取也没什么用，client通过HTTPS以及密钥来获取access_token，以保证安全。 为什么不直接用HTTPS重定向回client不是所有client都支持HTTPS，为了通用性 和安全性，才衍生出来这么一个code。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}]},{"title":"队列","slug":"队列","date":"2019-09-06T08:30:52.000Z","updated":"2019-09-06T08:32:21.627Z","comments":true,"path":"PHP/队列/","link":"","permalink":"https://sexyphoenix.github.io/PHP/队列/","excerpt":"","text":"前言 Laravel的队列可以用在轻量级的队列需求中。比如我们系统中的短信、邮件等功能，这些功能有一些普遍的特征，异步、重试、并发控制等。Laravel现在主要支持的队列服务有Null、Sync、Database、Redis、Beanstalkd、Sqs。在我们的项目中（消息中心、人事）用的主要是redis，接下来我会介绍下队列基于redis驱动的运行机制。 背景知识 Laravel启动后，加载config/app.php的providers数组中的服务提供者 QueueServiceProvider，在队列服务提供者中，已经注册了一系列相关服务。 在.env配置文件中，我们设置了QUEUE_DRIVER为redis，系统启动后会自动生成Redis连接，同时注册了Work消费者，队列监听器以及错误服务。在queue.php和database.php配置中都默认了相关的redis设置。 任务调度 调度如下： laravel 的队列服务由两个进程控制，一个是事件生产者（黑线），一个是事件消费者（黄线）。有三个队列，主队列 queues：default（下面default代替），延时队列 queues：default：delayed（下面delayed代替），待处理队列 queues：default：reserved（下面reserved代替）。所有的队列事件都由事件消费者去消费主队列中的事件。（队列名称default在queue.php中被定义） 1. 事件触发：dispatch(new Event())；事件触发后，dispatch判断Event是否继承队列类，是，将事件分发到队列执行流程中。队列执行流程会根据Event的延时属性判断，否，将Event放到即时处理queues：default 队列中，是，将Event放入延时 queues：default：delayed 队列中。 2. 消费：php artisan queue:work图中A、B、C、D为消费者进程依次执行步骤，淡黄色背景的代码备注都为对队列的操作命令（predis 实现redis api），每个备注里面对事件的操作要么一起成功，要么一起失败（Lua脚本）。 3. A： 对delayed、default队列操作A1：取出小于当前时间的（时间戳）所有Event，赋给val，删除delayed队列中0到val.length长度的Event（redis的有序集合有一个分数，有序集合根据这个分数从小到大排序，这里的时间戳就是分数）。A2：将上面获取的Event，放入到主队列 default。 4. B： 对reserved、default队列操作B1：取出小于当前时间的所有Event，赋给val，删除reserved队列中0到val长度的Event。B2：将上面获取的Event，放入到主队列 default。 5. C： 对default、reserved队列操作C1：取出主队列中的所有Event。C2：将Event放入reserved，且记录Event的执行次数（保留Event，由D执行后，根据Event执行结果处理这些Event）。 6. D： 处理Event（由C步骤得到的Event，交给D）根据得到的Event依次执行（也就是通知监听这个Event的所有监听者），同时删除reserved队列的相对应的Event（无论执行失败还是成功），如果执行失败会将任务放入reserved队列中，执行时间为1540097000（1540096910 + 90，90为设置的延时时间），以便下次执行。 结尾 以上就是Laravel队列所有的执行流程，当然里面包括执行失败的错误处理、如何通知监听者等细节都没讲，大家可以自行分析代码理解。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}]},{"title":"用户认证","slug":"用户认证","date":"2019-09-06T08:23:46.000Z","updated":"2019-09-06T08:29:51.672Z","comments":true,"path":"PHP/用户认证/","link":"","permalink":"https://sexyphoenix.github.io/PHP/用户认证/","excerpt":"","text":"前期准备Laravel的权限配置文件位于 config/auth.php，Laravel的认证组件由“guards”和“providers”组成，Guard 通过 session 来维护用户登录的状态。Provider 是登录以及访问页面的时候获取用户的信息。本篇主要讲的是如何自定义Provider ，获取用户信息。 config/auth.php文件Laravel提供了两种guard，web以及api，采取默认的web认证。在guards的web中，用了users提供者。接下来就需要注意了，我们自定义了服务提供者，就需要换到新的providers。首先，定义一个使用新驱动的provider： 123456 &apos;providers&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;Focus&apos;, //名称自定义，这里为Focus &apos;model&apos; =&gt; App\\Models\\User::class, //Model放在Models文件夹下 ],], Notes: 默认提供了两种驱动database和eloquent，而这两种的提供者分别是DatabaseUserProvider和EloquentUserProvider，都处于laravel\\framework\\src\\Illuminate\\Auth文件夹下，实现了UserProvider，我们自定义的 Focus provider 也将实现UserProvider。 生成路由和视图1php artisan make:auth //命令可快速生成认证所需要的路由和视图 Http/Controllers 和 resources/views下会相应生成控制器和视图默认用的Email，我们用username LoginController：//添加此方法，返回username 123public function username()&#123; return &apos;username&apos;;&#125; login.blade.php：将邮箱改为域账号，email 改为username 数据库修改.env配置中的数据库信息。 1php artisan make:model Models/User // 使用命令创建User模型 默认User是继承Model的，需要修改。 123456789use Illuminate\\Foundation\\Auth\\User as Authenticatable; //引入Authenticatableclass User extends Authenticatable&#123; protected $table = &apos;employee&apos;; protected $primaryKey = &apos;employee_id&apos;; //can set all fields to user model protected $guarded = [];&#125; 为什么要引入Authenticatable呢，是因为Authenticatable实现了Illuminate\\Contracts\\Auth\\Authenticatable接口，而FocusUserProvider 需要用到接口的实现。 创建扩展在app下新建 Extensions/FocusUserProvider 文件，参考DatabaseUserProvider和EloquentUserProvider，实现UserProvider： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374namespace App\\Extensions;use App\\Services\\LdapValidator;use Illuminate\\Support\\Str;use Illuminate\\Contracts\\Auth\\UserProvider;use \\Illuminate\\Contracts\\Auth\\Authenticatable; class LaravelUserProvider implements UserProvider &#123; protected $model; public function __construct($model) &#123; $this-&gt;model = $model; &#125; //登录成功后，通过此方法获取用户信息，返回匹配该ID的 Authenticatable 实现 public function retrieveById($identifier) &#123; //此处可以将信息放入缓存，缓解数据库压力。 $model = $this-&gt;createModel(); return $model-&gt;newQuery() -&gt;where($model-&gt;getAuthIdentifierName(), $identifier) -&gt;first(); &#125; public function retrieveByToken($identifier, $token) &#123; &#125; public function updateRememberToken(Authenticatable $user, $token) &#123; &#125; //该方法可以根据账号名去查询数据库是否存在匹配的账号 public function retrieveByCredentials(array $credentials) &#123; if (empty($credentials)) &#123; return; &#125; // First we will add each credential element to the query as a where clause. // Then we can execute the query and, if we found a user, return it in a // Eloquent User &quot;model&quot; that will be utilized by the Guard instances. $query = $this-&gt;createModel()-&gt;newQuery(); foreach ($credentials as $key =&gt; $value) &#123; if (! Str::contains($key, &apos;password&apos;)) &#123; $query-&gt;where($key, $value); &#125; &#125; return $query-&gt;first(); &#125; //该方法可以验证密码是否正确，因为我们是ldap登录，可以在此验证域账号 public function validateCredentials(Authenticatable $user, array $credentials) &#123; //LdapValidator类是为了验证域密码的，放在了app/Services，在上面已经引入 $Ldap = new LdapValidator($user-&gt;username, $credentials[&apos;password&apos;]); return $Ldap-&gt;validatePassword(); &#125; /** * Create a new instance of the model. * * @return \\Illuminate\\Database\\Eloquent\\Model */ public function createModel() &#123; $class = &apos;\\\\&apos;.ltrim($this-&gt;model, &apos;\\\\&apos;); return new $class; &#125;&#125; 注册提供者Laravel 提供了AuthServiceProvider， 我们可以在这里注册。 12345678910public function boot()&#123; $this-&gt;registerPolicies(); //Focus为auth.php里面定义的驱动 Auth::provider(&apos;Focus&apos;, function($app, array $config)&#123; return new FocusUserProvider ($config[&apos;model&apos;]); &#125;);&#125; 下面就可以访问http://你的域名/login 登录系统","categories":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://sexyphoenix.github.io/categories/PHP/"}]},{"title":"生命的意义","slug":"生命的意义","date":"2019-09-06T08:11:47.000Z","updated":"2019-09-06T08:21:47.640Z","comments":true,"path":"PHP/生命的意义/","link":"","permalink":"https://sexyphoenix.github.io/PHP/生命的意义/","excerpt":"","text":"我们该如何找出生命的意义呢？ 我（霍金）认为答案非常清楚 意义本身不过就是 每个人在大脑里建构的现实模型其中一部分 生命的意义为何 全由你来选择 个人来说 我很乐意 我们每一个人都赋予宇宙意义 如宇宙学家卡尔·萨根所说 我们是宇宙对自己的省思 意义只能存在于人类心智的架构内 如此一来 生命的意义就不在外面某处 而在我们的脑海里 就许多方面来说 我们也因此成了万物之灵","categories":[],"tags":[],"keywords":[]}]}